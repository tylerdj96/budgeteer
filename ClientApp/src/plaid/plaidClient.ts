/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.8.2.0 (NJsonSchema v10.2.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, {
    AxiosError,
    AxiosInstance,
    AxiosRequestConfig,
    AxiosResponse,
    CancelToken,
} from 'axios'

export interface IPlaidClient {
    getTransactions(
        startDate: Date | undefined,
        endDate: Date | undefined
    ): Promise<any | null>
    getLinkToken(body: TokenCreateDto): Promise<LinkResponse>
    exchangePublicToken(publicToken: string): Promise<string>
}

export class PlaidClient implements IPlaidClient {
    private instance: AxiosInstance
    private baseUrl: string
    private oktaToken: string

    constructor(oktaToken: string, baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create()
        this.baseUrl =
            baseUrl !== undefined && baseUrl !== null
                ? baseUrl
                : 'https://localhost:5001'
        this.oktaToken = oktaToken
    }

    getTransactions(
        startDate: Date | undefined,
        endDate: Date | undefined,
        cancelToken?: CancelToken | undefined
    ): Promise<any | null> {
        let url_ = this.baseUrl + '/api/v1/transactions?'
        if (startDate === null)
            throw new Error("The parameter 'startDate' cannot be null.")
        else if (startDate !== undefined)
            url_ +=
                'startDate=' +
                encodeURIComponent(startDate ? '' + startDate.toJSON() : '') +
                '&'
        if (endDate === null)
            throw new Error("The parameter 'endDate' cannot be null.")
        else if (endDate !== undefined)
            url_ +=
                'endDate=' +
                encodeURIComponent(endDate ? '' + endDate.toJSON() : '') +
                '&'
        url_ = url_.replace(/[?&]$/, '')

        let options = <AxiosRequestConfig>{
            responseType: 'blob',
            method: 'GET',
            url: url_,
            headers: {
                Accept: 'application/octet-stream',
                Authorization: `Bearer ${this.oktaToken}`,
            },
            cancelToken,
        }

        return this.instance
            .request(options)
            .then((response: AxiosResponse) => {
                return response.data
            })
            .catch((error: any) => {
                console.error(error)
            })
    }

    getLinkToken(
        body: TokenCreateDto,
        cancelToken?: CancelToken | undefined
    ): Promise<LinkResponse> {
        let url = this.baseUrl + '/api/v1/link'
        url = url.replace(/[?&]$/, '')

        const content_ = JSON.stringify(body)

        let options = <AxiosRequestConfig>{
            data: content_,
            method: 'POST',
            url: url,
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
                Authorization: `Bearer ${this.oktaToken}`,
            },
            cancelToken,
        }

        return this.instance
            .request(options)
            .then((response: AxiosResponse) => {
                return response.data
            })
            .catch((error: any) => {
                console.error(error)
            })
    }

    exchangePublicToken(
        publicToken: string,
        cancelToken?: CancelToken | undefined
    ): Promise<string> {
        let url = this.baseUrl + '/api/v1/token'
        url = url.replace(/[?&]$/, '')

        const content_ = JSON.stringify(publicToken)

        let options = <AxiosRequestConfig>{
            data: content_,
            method: 'POST',
            url: url,
            headers: {
                'Content-Type': 'application/json',
                Accept: 'application/json',
                Authorization: `Bearer ${this.oktaToken}`,
            },
            cancelToken,
        }

        return this.instance
            .request(options)
            .then((response: AxiosResponse) => {
                return response.data
            })
            .catch((error: any) => {
                console.error(error)
            })
    }
}

export interface LinkResponse {
    link_token?: string | undefined
    expiration?: string | undefined
    request_id?: string | undefined
}

export interface TokenCreateDto {
    client_id?: string | undefined
    secret?: string | undefined
    client_name?: string | undefined
    country_codes?: string[] | undefined
    language?: string | undefined
    user?: User | undefined
    products?: string[] | undefined
}

export interface User {
    client_user_id?: string | undefined
}
